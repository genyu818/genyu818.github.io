<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on WANG, HENGYU</title>
    <link>http://genyu818.github.io/posts/</link>
    <description>Recent content in Posts on WANG, HENGYU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Jul 2020 15:11:08 +0800</lastBuildDate>
    
	<atom:link href="http://genyu818.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java泛型</title>
      <link>http://genyu818.github.io/2020/java%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Wed, 08 Jul 2020 15:11:08 +0800</pubDate>
      
      <guid>http://genyu818.github.io/2020/java%E6%B3%9B%E5%9E%8B/</guid>
      <description>听过无数次只有了解Java高级特性才算是入了门，这次我们就来看一下Java的泛型。
1.什么是泛型？ 从各个网站，论坛看过很多关于泛型的讲解，总感觉少点意思，直到看到廖雪峰大神对于泛型的讲解，总算感觉比较透彻。看泛型之前我们先来看一个Java标准库里的ArrayList，我们直接看一下它的设计思路，可以看到实际上ArrayList中实际就是Object[]数组，配合size，以及一些add等操作方法。
public class ArrayList { private Object[] array; private int size; public void add(Object e) {...} public void remove(int index) {...} public Object get(int index) {...} } 但是如果使用ArrayList来存储String类型就会又很多缺点
 需要强制转型（Object -&amp;gt; String） 容易出问题  例如，代码必须这么写：
ArrayList list = new ArrayList(); list.add(&amp;#34;Hello&amp;#34;); // 获取到Object，必须强制转型为String: String first = (String) list.get(0); 如果想避免这些问题，代码应该这样写
public class ArrayList { private String[] array; private int size; public void add(Object e) {...} public void remove(int index) {.</description>
    </item>
    
    <item>
      <title>五层协议</title>
      <link>http://genyu818.github.io/2020/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 08 Jul 2020 10:12:07 +0800</pubDate>
      
      <guid>http://genyu818.github.io/2020/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid>
      <description>计算机网络体系结构 计算机网络中有两种协议栈OSI协议和TCP/IP协议，为了方便我们中和了这两个协议的优点，采用五层协议的体系结构，这样既简洁，又清晰。
应用层 我截取麻省Computer Network中对于应用层的定义。
Sitting at Layer 7 &amp;ndash; the very top of the Open Systems Interconnection (OSI) communications model &amp;ndash; the application layer provides services for an application program to ensure that effective communication with another application program on a network is possible. The application layer should not be thought of as an application as most people understand it. Instead, the application layer is a component within an application that controls the communication method to other devices.</description>
    </item>
    
    <item>
      <title>Java异常</title>
      <link>http://genyu818.github.io/2020/java%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Tue, 07 Jul 2020 13:31:09 +0800</pubDate>
      
      <guid>http://genyu818.github.io/2020/java%E5%BC%82%E5%B8%B8/</guid>
      <description>JAVA中的异常介绍 异常是什么？ 异常就是阻止程序运行的问题，当程序出现异常时候，系统会自动的生成一个Exception来通知程序程序作出相应的处理。Java的异常类型有很多种。 根据Java异常继承结构，我们可以知道所有的异常类都继承于Throwable类，而该类又有Error类，Exception类两个子类。而Exception类又分为受检查异常和非受检查异常（运行异常）。我们来逐一看一下。
Java异常中的Error Error一般表示编译时或者系统错误，例如：虚拟机相关的错误，系统崩溃（例如：我们开发中有时会遇到的OutOfMemoryError）等。这种错误无法恢复或不可捕获,将导致应用程序中断,通常应用程序无法处理这些错误,因此也不应该试图用catch来进行捕获。
一般来说出现Error我们不应该也无法去处理。
Java中的Exception 上面我们有介绍，Java异常的中的Exception分为受检查异常和运行时异常（不受检查异常）。下面我们展开介绍。
Java中的受检查类 受检查类指，编译器在编译过程中对于受检查异常类必须要进行try&amp;hellip;catch或者throw处理，否则无法通过编译。常见的受检查类包括： IO操作，ClassNotFindException，线程操作等。
Java中的非受检查类（运行时异常） RuntimeException及其子类都统称为非受检查异常，例如：NullPointExecrption、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。
Java异常处理的基本语法 1.try-catch try{ //code that might generate exceptions }catch(Exception e){ //the code of handling exception1 }catch(Exception e){ //the code of handling exception2 } 要明白异常捕获，还要理解监控区域（guarded region）的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
因而可知，上述try-catch所描述的即是监控区域，关键词try后的一对大括号将一块可能发生异常的代码包起来，即为监控区域。Java方法在运行过程中发生了异常，则创建异常对象。将异常抛出监控区域之外，由Java运行时系统负责寻找匹配的catch子句来捕获异常。若有一个catch语句匹配到了，则执行该catch块中的异常处理代码，就不再尝试匹配别的catch块了。
举个例子算术异常：
public class TestException { public static void main(String[] args) { int a = 1; int b = 0; try { // try监控区域  if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出异常  System.</description>
    </item>
    
    <item>
      <title>SSM DEMO1</title>
      <link>http://genyu818.github.io/2020/ssm-demo1/</link>
      <pubDate>Tue, 07 Jul 2020 11:41:15 +0800</pubDate>
      
      <guid>http://genyu818.github.io/2020/ssm-demo1/</guid>
      <description>1.前言 最近在一家公司实习，之前一直没基础过JAVA后端，现在算是从0开始学习，想着线从头自己搭建出一个程序跑通，但是网上看了很多教程，有的太过于杂乱，有的就是把Google上的内容翻译一下直接搬了过来。所以写下这篇文章，希望对新手们有点帮助，大佬们轻喷谢谢！
言归正传，到底什么是SSM框架？ The SSM framework is a combination of Spring MVC, Spring and Mybatis framework. It is a standard MVC pattern. 这是一段截取到的直白解释，SSM框架就是由Spring MVC, Spring and Mybatis组成遵循 MVC模式的框架。感觉说了等于不说，是不是？ 没关系我们直观的看一个图。
SSM实现原理也好，配置方式也好，把那些先都放一边，先用大白话的方式看一下SSM框架到底是个什么东西。这样我们可以清晰的看到SSM框架就是Spring对Mybatis要求，让Mybatis去对数据库进行操作，然后对SpringMVC要求，把拿到并且处理好的数据传给Web。
2.实战 1. 实战说明 非常简单，就是利用SSM框架以及SQL server实现一个简单登录，注册以及修改密码的小demo。 如果有时间以及经历，我将一直会维护下去，去在学习的过程中，添加更多的东西，例如增加一些功能，添加一些样式等等。
2.jar需要的jar包 NOTES：博主最早使用Maven，但是发现Maven对新手并不是太友好，因为大家跟着教程去实现的时候，很容易看了很多教程导致版本不一致，重复多个版本jar包。
我已经将该项目上传到GitHub上，可以根据需要自己去下载jar包。
Jar包下载
3. 准备数据库（SQL server） 创建数据库，并且把id设为自增长，然后随便插入两条数据。
CREATE TABLE user_db ( id int PRIMARY KEY IDENTITY, user_name varchar(255), user_password varchar(255), ) INSERT INTO dbo.user_db (user_name, user_password) VALUES &amp;#39;wang&amp;#39;, &amp;#39;wang123&amp;#39; INSERT INTO dbo.user_db (user_name, user_password) VALUES &amp;#39;li&amp;#39;, &amp;#39;li123&amp;#39; Notes：推荐一个非常好用的sql语句的互换网站 Mysql 转SQL server。</description>
    </item>
    
    <item>
      <title>Java反射</title>
      <link>http://genyu818.github.io/2020/java%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Fri, 03 Jul 2020 12:58:05 +0800</pubDate>
      
      <guid>http://genyu818.github.io/2020/java%E5%8F%8D%E5%B0%84/</guid>
      <description>一、 Java中反射的机制 Java反射机制在程序运行时候，对于任意一个类都能动态的获取到类的属性以及方法。反射机制很重要的就是运行时，其使得我们可以在程序运行对未知的.class进行加载，编译，以及探索。 就是说Java程序在加载一个运行时才得知名称的.class文件，然后获悉其构造过程，属性，以及方法。
反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。
二、反射的主要用途 反射最重要的用途就是开发各种通用框架。 很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。
其次，当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射
三、反射的作用 我们定义一个FatherClass类， 还有一个SonClass类继承于FatherClass类。如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。
FatherClass.java public class FatherClass { public String mFatherName; public int mFatherAge; public void printFatherMsg(){} } SonClass.java public class SonClass extends FatherClass{ private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg(){ System.out.println(&amp;#34;Son Msg - name : &amp;#34; + mSonName + &amp;#34;; age : &amp;#34; + mSonAge); } private void setSonName(String name){ mSonName = name; } private void setSonAge(int age){ mSonAge = age; } private int getSonAge(){ return mSonAge; } private String getSonName(){ return mSonName; } } 一、获取类的变量信息 /** * 通过反射获取类的所有变量 */ private static void printFields(){ //1.</description>
    </item>
    
  </channel>
</rss>