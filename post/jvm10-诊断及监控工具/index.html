<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM-10  诊断及监控工具 - Hengyu&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Hengyu" /><meta name="description" content="JVM监控以及诊断工具 1. 命令行 1.1 jps: 查看正在运行的Java进程 jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/jvm10-%E8%AF%8A%E6%96%AD%E5%8F%8A%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM-10  诊断及监控工具" />
<meta property="og:description" content="JVM监控以及诊断工具 1. 命令行 1.1 jps: 查看正在运行的Java进程 jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/jvm10-%E8%AF%8A%E6%96%AD%E5%8F%8A%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-08T23:20:15&#43;08:00" />
<meta property="article:modified_time" content="2022-04-08T23:20:15&#43;08:00" />

<meta itemprop="name" content="JVM-10  诊断及监控工具">
<meta itemprop="description" content="JVM监控以及诊断工具 1. 命令行 1.1 jps: 查看正在运行的Java进程 jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程"><meta itemprop="datePublished" content="2022-04-08T23:20:15&#43;08:00" />
<meta itemprop="dateModified" content="2022-04-08T23:20:15&#43;08:00" />
<meta itemprop="wordCount" content="8942">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM-10  诊断及监控工具"/>
<meta name="twitter:description" content="JVM监控以及诊断工具 1. 命令行 1.1 jps: 查看正在运行的Java进程 jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Hengyu</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Hengyu</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM-10  诊断及监控工具</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-08 </span>
        <div class="post-category">
            <a href="/categories/jvm/"> JVM </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#jvm监控以及诊断工具">JVM监控以及诊断工具</a>
      <ul>
        <li><a href="#1命令行">1.	命令行</a>
          <ul>
            <li><a href="#11jps-查看正在运行的java进程">1.1	jps: 查看正在运行的Java进程</a></li>
            <li><a href="#12jstat-查看jvm统计信息">1.2	jstat: 查看JVM统计信息</a></li>
            <li><a href="#13jinfo实时查看和修改jvm配置参数">1.3	jinfo：实时查看和修改JVM配置参数</a></li>
            <li><a href="#14jmap导出内存映像文件内存使用情况">1.4	jmap：导出内存映像文件&amp;内存使用情况</a></li>
            <li><a href="#15jhatjdk自带堆分析工具">1.5	jhat：JDK自带堆分析工具</a></li>
            <li><a href="#16jstack打印jvm中线程快照">1.6	jstack：打印JVM中线程快照</a></li>
            <li><a href="#17jcmd多功能命令行">1.7	jcmd：多功能命令行</a></li>
          </ul>
        </li>
        <li><a href="#2gui">2.	GUI</a>
          <ul>
            <li><a href="#21jprofiler">2.1	JProfiler</a></li>
            <li><a href="#22arthas">2.2	Arthas</a></li>
          </ul>
        </li>
        <li><a href="#3分析gc日志">3.	分析GC日志</a>
          <ul>
            <li><a href="#31gc分类">3.1	GC分类</a></li>
            <li><a href="#32gc日志分类">3.2	GC日志分类</a></li>
          </ul>
        </li>
        <li><a href="#53-gc日志结构剖析">5.3. GC日志结构剖析</a></li>
        <li><a href="#54-gc日志分析工具">5.4. GC日志分析工具</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="jvm监控以及诊断工具">JVM监控以及诊断工具</h1>
<h2 id="1命令行">1.	命令行</h2>
<h3 id="11jps-查看正在运行的java进程">1.1	jps: 查看正在运行的Java进程</h3>
<p>jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p>
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。</p>
<p>基本使用语法为：jps [options] [hostid]</p>
<p>我们还可以通过追加参数，来打印额外的信息。</p>
<p><strong>options参数</strong></p>
<ul>
<li>
<p>-q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id。不显示主类的名称等</p>
</li>
<li>
<p>-l：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</p>
</li>
<li>
<p>-m：输出虚拟机进程启动时传递给主类main()的参数</p>
</li>
<li>
<p>-v：列出虚拟机进程启动时的JVM参数。比如：-Xms20m -Xmx50m是启动程序指定的jvm参数。</p>
</li>
</ul>
<h3 id="12jstat-查看jvm统计信息">1.2	jstat: 查看JVM统计信息</h3>
<p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p>
<p><strong>基本使用语法为：jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</strong></p>
<p>查看命令相关参数：jstat-h 或 jstat-help</p>
<p>其中vmid是进程id号，也就是jps之后看到的前面的号码</p>
<p><strong>option参数</strong></p>
<p>选项option可以由以下值构成。</p>
<p>类装载相关的：</p>
<ul>
<li>-class：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p>垃圾回收相关的：</p>
<ul>
<li>
<p>-gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</p>
</li>
<li>
<p>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p>
</li>
<li>
<p>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</p>
</li>
<li>
<p>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</p>
</li>
<li>
<p>-gcnew：显示新生代GC状况</p>
</li>
<li>
<p>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</p>
</li>
<li>
<p>-geold：显示老年代GC状况</p>
</li>
<li>
<p>-gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p>
</li>
<li>
<p>-gcpermcapacity：显示永久代使用到的最大、最小空间。</p>
</li>
</ul>
<p>JIT相关的：</p>
<ul>
<li>
<p>-compiler：显示JIT编译器编译过的方法、耗时等信息</p>
</li>
<li>
<p>-printcompilation：输出已经被JIT编译的方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>EC</td>
<td>Eden区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>Eden区已使用的大小</td>
</tr>
<tr>
<td>S0C</td>
<td>幸存者0区的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>幸存者1区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>幸存者0区已使用的大小</td>
</tr>
<tr>
<td>S1U</td>
<td>幸存者1区已使用的大小</td>
</tr>
<tr>
<td>MC</td>
<td>元空间的大小</td>
</tr>
<tr>
<td>MU</td>
<td>元空间已使用的大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代的大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代已使用的大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间的大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间已使用的大小</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时young gc的次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时young gc消耗时间（秒）</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时full gc的次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时的full gc的消耗时间（秒）</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc的总时间</td>
</tr>
</tbody>
</table>
<p><strong>interval参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p>
<p><strong>count参数：</strong> 用于指定查询的总次数</p>
<p><strong>-t参数：</strong> 可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p>
<p><strong>-h参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<p><strong>补充：</strong> jstat还可以用来判断是否出现内存泄漏。</p>
<p>第1步：在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p>
<p>第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>
<h3 id="13jinfo实时查看和修改jvm配置参数">1.3	jinfo：实时查看和修改JVM配置参数</h3>
<p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p>
<p>基本使用语法为：jinfo [options] pid</p>
<p>说明：java 进程ID必须要加上</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [+-]name</td>
<td>开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>设定对应名称的参数</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody>
</table>
<h3 id="14jmap导出内存映像文件内存使用情况">1.4	jmap：导出内存映像文件&amp;内存使用情况</h3>
<p>jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅jmap工具的具体使用方式和一些标准选项配置。</p>
<p>基本使用语法为：</p>
<ul>
<li>jmap [option] <pid></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成dump文件（Java堆转储快照），-dump:live只保存堆中的存活对象</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live只统计堆中的存活对象</td>
</tr>
<tr>
<td>-J <flag></td>
<td>传递参数给jmap启动的jvm</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象，仅linux/solaris平台有效</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息，仅linux/solaris平台有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有任何响应时，强制执行生成dump文件，仅linux/solaris平台有效</td>
</tr>
</tbody>
</table>
<p>说明：这些参数和linux下输入显示的命令多少会有不同，包括也受jdk版本的影响。</p>
<p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p>
<h3 id="15jhatjdk自带堆分析工具">1.5	jhat：JDK自带堆分析工具</h3>
<p>jhat(JVM Heap Analysis Tool)：Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p>
<p>使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析。</p>
<p>说明：jhat命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替。</p>
<p>基本适用语法：jhat <option> <dumpfile></p>
<table>
<thead>
<tr>
<th>option参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-stack false｜true</td>
<td>关闭｜打开对象分配调用栈跟踪</td>
</tr>
<tr>
<td>-refs false｜true</td>
<td>关闭｜打开对象引用跟踪</td>
</tr>
<tr>
<td>-port port-number</td>
<td>设置jhat HTTP Server的端口号，默认7000</td>
</tr>
<tr>
<td>-exclude exclude-file</td>
<td>执行对象查询时需要排除的数据成员</td>
</tr>
<tr>
<td>-baseline exclude-file</td>
<td>指定一个基准堆转储</td>
</tr>
<tr>
<td>-debug int</td>
<td>设置debug级别</td>
</tr>
<tr>
<td>-version</td>
<td>启动后显示版本信息就退出</td>
</tr>
<tr>
<td>-J <flag></td>
<td>传入启动参数，比如-J-Xmx512m</td>
</tr>
</tbody>
</table>
<h3 id="16jstack打印jvm中线程快照">1.6	jstack：打印JVM中线程快照</h3>
<p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况。</p>
<p>在thread dump中，要留意下面几种状态</p>
<ul>
<li>
<p>死锁，Deadlock（重点关注）</p>
</li>
<li>
<p>等待资源，Waiting on condition（重点关注）</p>
</li>
<li>
<p>等待获取监视器，Waiting on monitor entry（重点关注）</p>
</li>
<li>
<p>阻塞，Blocked（重点关注）</p>
</li>
<li>
<p>执行中，Runnable</p>
</li>
<li>
<p>暂停，Suspended</p>
</li>
<li>
<p>对象等待中，Object.wait() 或 TIMED＿WAITING</p>
</li>
<li>
<p>停止，Parked</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>option参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody>
</table>
<h3 id="17jcmd多功能命令行">1.7	jcmd：多功能命令行</h3>
<p>在JDK 1.7以后，新增了一个命令行工具jcmd。它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。</p>
<p>jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代jmap命令</p>
<p>**jcmd -l：**列出所有的JVM进程</p>
<p>**jcmd 进程号 help：**针对指定的进程，列出支持的所有具体命令</p>
<p>**jcmd 进程号 具体命令：**显示指定进程的指令命令的数据</p>
<ul>
<li>
<p>Thread.print 可以替换 jstack指令</p>
</li>
<li>
<p>GC.class_histogram 可以替换 jmap中的-histo操作</p>
</li>
<li>
<p>GC.heap_dump 可以替换 jmap中的-dump操作</p>
</li>
<li>
<p>GC.run 可以查看GC的执行情况</p>
</li>
<li>
<p>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的-t操作</p>
</li>
<li>
<p>VM.system_properties 可以替换 jinfo -sysprops 进程id</p>
</li>
<li>
<p>VM.flags 可以获取JVM的配置参数信息</p>
</li>
</ul>
<h2 id="2gui">2.	GUI</h2>
<h3 id="21jprofiler">2.1	JProfiler</h3>
<p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p><strong>特点：</strong></p>
<ul>
<li>
<p>使用方便、界面操作友好（简单且强大）</p>
</li>
<li>
<p>对被分析的应用影响小（提供模板）</p>
</li>
<li>
<p>CPU，Thread，Memory分析功能尤其强大</p>
</li>
<li>
<p>支持对jdbc，noSql，jsp，servlet，socket等进行分析</p>
</li>
<li>
<p>支持多种模式（离线，在线）的分析</p>
</li>
<li>
<p>支持监控本地、远程的JVM</p>
</li>
<li>
<p>跨平台，拥有多种操作系统的安装版本</p>
</li>
</ul>
<p><strong>主要功能：</strong></p>
<ul>
<li>
<p>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</p>
</li>
<li>
<p>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</p>
</li>
<li>
<p>3-线程和锁：JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</p>
</li>
<li>
<p>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</p>
</li>
</ul>
<p>官网地址：https://www.ej-technologies.com/products/jprofiler/overview.html</p>
<p><strong>数据采集方式：</strong></p>
<p>JProfier数据采集方式分为两种：Sampling（样本采集）和Instrumentation（重构模式）</p>
<p><strong>Instrumentation</strong>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。</p>
<ul>
<li>
<p>优点：功能强大。在此设置中，调用堆栈信息是准确的。</p>
</li>
<li>
<p>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高（取决于Filter的控制）。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</p>
</li>
</ul>
<p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p>
<ul>
<li>
<p>优点：对CPU的开销非常低，对应用影响小（即使你不配置任何Filter）</p>
</li>
<li>
<p>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</p>
</li>
</ul>
<p>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</p>
<h3 id="22arthas">2.2	Arthas</h3>
<p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？阿里巴巴开源的性能分析神器Arthas应运而生。</p>
<p>Arthas是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。Arthas 支持JDK 6＋，支持Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>
<p>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</p>
</li>
<li>
<p>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</p>
</li>
<li>
<p>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</p>
</li>
<li>
<p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</p>
</li>
<li>
<p>是否有一个全局视角来查看系统的运行状况？</p>
</li>
<li>
<p>有什么办法可以监控到JVM的实时运行状态？</p>
</li>
<li>
<p>怎么快速定位应用的热点，生成火焰图？</p>
</li>
</ul>
<p>Arthas只是一个java程序，所以可以直接用java -jar运行。</p>
<p>除了在命令行查看外，Arthas目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 http://127.0.0.1:8563/ 访问，页面上的操作模式和控制台完全一样。</p>
<p><strong>基础指令</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响
stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出
<span class="nb">help</span> 查看命令帮助信息
cat 打印文件内容，和linux里的cat命令类似
<span class="nb">echo</span> 打印参数，和linux里的echo命令类似
grep 匹配查找，和linux里的gep命令类似
tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似
<span class="nb">pwd</span> 返回当前的工作目录，和linux命令类似
cls 清空当前屏幕区域
session 查看当前会话的信息
reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类
version 输出当前目标Java进程所加载的 Arthas版本号
<span class="nb">history</span> 打印命令历史
keymap Arthas快捷键列表及自定义快捷键
</code></pre></td></tr></table>
</div>
</div><p><strong>jvm相关</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">dashboard 当前系统的实时数据面板
thread 查看当前JVM的线程堆栈信息
jvm 查看当前JVM的信息
sysprop 查看和修改JVM的系统属性
sysem 查看JVM的环境变量
vmoption 查看和修改JVM里诊断相关的option
perfcounter 查看当前JVM的 Perf Counter信息
logger 查看和修改logger
getstatic 查看类的静态属性
ognl 执行ognl表达式
mbean 查看 Mbean的信息
heapdump dump java heap，类似jmap命令的 heap dump功能
</code></pre></td></tr></table>
</div>
</div><p><strong>class/classloader相关</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sc 查看JVM已加载的类信息
	-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次
	-E 开启正则表达式匹配，默认为通配符匹配
	-f 输出当前类的成员变量信息（需要配合参数-d一起使用）
	-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出
sm 查看已加载类的方法信息
	-d 展示每个方法的详细信息
	-E 开启正则表达式匹配,默认为通配符匹配
jad 反编译指定已加载类的源码
mc 内存编译器，内存编译.java文件为.class文件
retransform 加载外部的.class文件, retransform到JVM里
redefine 加载外部的.class文件，redefine到JVM里
dump dump已加载类的byte code到特定目录
classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource
	-t 查看classloader的继承树
	-l 按类加载实例查看统计信息
	-c 用classloader对应的hashcode来查看对应的 Jar urls
</code></pre></td></tr></table>
</div>
</div><p><strong>monitor/watch/trace相关</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">monitor 方法执行监控，调用次数、执行时间、失败率
	-c 统计周期，默认值为120秒
watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看
	-b 在方法调用之前观察<span class="o">(</span>默认关闭<span class="o">)</span>
	-e 在方法异常之后观察<span class="o">(</span>默认关闭<span class="o">)</span>
	-s 在方法返回之后观察<span class="o">(</span>默认关闭<span class="o">)</span>
	-f 在方法结束之后<span class="o">(</span>正常返回和异常返回<span class="o">)</span>观察<span class="o">(</span>默认开启<span class="o">)</span>
	-x 指定输岀结果的属性遍历深度,默认为0
trace 方法内部调用路径,并输出方法路径上的每个节点上耗时
	-n 执行次数限制
stack 输出当前方法被调用的调用路径
tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测
</code></pre></td></tr></table>
</div>
</div><p><strong>其他</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">obs 列出所有job
<span class="nb">kill</span> 强制终止任务
<span class="nb">fg</span> 将暂停的任务拉到前台执行
<span class="nb">bg</span> 将暂停的任务放到后台执行
grep 搜索满足条件的结果
plaintext 将命令的结果去除ANSI颜色
wc 按行统计输出结果
options 查看或设置Arthas全局开关
profiler 使用async-profiler对应用采样，生成火焰图
</code></pre></td></tr></table>
</div>
</div><h2 id="3分析gc日志">3.	分析GC日志</h2>
<h3 id="31gc分类">3.1	GC分类</h3>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li>
<p>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
</li>
<li>
<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li>
</ul>
</li>
<li>
<ul>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>
<p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</p>
</li>
<li>
<p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h3 id="32gc日志分类">3.2	GC日志分类</h3>
<p><strong>MinorGC</strong></p>
<p>MinorGC（或young GC或YGC）日志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">GC</span> <span class="o">(</span><span class="n">Allocation</span> <span class="n">Failure</span><span class="o">)</span> <span class="o">[</span><span class="n">PSYoungGen</span><span class="o">:</span> <span class="n">31744K</span><span class="o">-&gt;</span><span class="n">2192K</span> <span class="o">(</span><span class="n">36864K</span><span class="o">)</span> <span class="o">]</span> <span class="n">31744K</span><span class="o">-&gt;</span><span class="n">2200K</span> <span class="o">(</span><span class="n">121856K</span><span class="o">),</span> <span class="n">0</span><span class="o">.</span><span class="na">0139308</span> <span class="n">secs</span><span class="o">]</span> <span class="o">[</span><span class="n">Times</span><span class="o">:</span> <span class="n">user</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">05</span> <span class="n">sys</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">01</span><span class="o">,</span> <span class="n">real</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">01</span> <span class="n">secs</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>FullGC</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">Full</span> <span class="nf">GC</span> <span class="o">(</span><span class="n">Metadata</span> <span class="n">GC</span> <span class="n">Threshold</span><span class="o">)</span> <span class="o">[</span><span class="n">PSYoungGen</span><span class="o">:</span> <span class="n">5104K</span><span class="o">-&gt;</span><span class="n">0K</span> <span class="o">(</span><span class="n">132096K</span><span class="o">)</span> <span class="o">]</span> <span class="o">[</span><span class="n">Par01dGen</span><span class="o">:</span> <span class="n">416K</span><span class="o">-&gt;</span><span class="n">5453K</span> <span class="o">(</span><span class="n">50176K</span><span class="o">)</span> <span class="o">]</span><span class="n">5520K</span><span class="o">-&gt;</span><span class="n">5453K</span> <span class="o">(</span><span class="n">182272K</span><span class="o">),</span> <span class="o">[</span><span class="n">Metaspace</span><span class="o">:</span> <span class="n">20637K</span><span class="o">-&gt;</span><span class="n">20637K</span> <span class="o">(</span><span class="n">1067008K</span><span class="o">)</span> <span class="o">],</span> <span class="n">0</span><span class="o">.</span><span class="na">0245883</span> <span class="n">secs</span><span class="o">]</span> <span class="o">[</span><span class="n">Times</span><span class="o">:</span> <span class="n">user</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">06</span> <span class="n">sys</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">00</span><span class="o">,</span> <span class="n">real</span><span class="o">=</span><span class="n">0</span><span class="o">.</span><span class="na">02</span> <span class="n">secs</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="53-gc日志结构剖析">5.3. GC日志结构剖析</h2>
<p><strong>透过日志看垃圾收集器</strong></p>
<ul>
<li>
<p>Serial收集器：新生代显示 &ldquo;[DefNew&rdquo;，即 Default New Generation</p>
</li>
<li>
<p>ParNew收集器：新生代显示 &ldquo;[ParNew&rdquo;，即 Parallel New Generation</p>
</li>
<li>
<p>Parallel Scavenge收集器：新生代显示&quot;[PSYoungGen&quot;，JDK1.7使用的即PSYoungGen</p>
</li>
<li>
<p>Parallel Old收集器：老年代显示&quot;[ParoldGen&quot;</p>
</li>
<li>
<p>G1收集器：显示”garbage-first heap“</p>
</li>
</ul>
<p><strong>透过日志看GC原因</strong></p>
<ul>
<li>
<p>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</p>
</li>
<li>
<p>Metadata GCThreshold：Metaspace区不够用了</p>
</li>
<li>
<p>FErgonomics：JVM自适应调整导致的GC</p>
</li>
<li>
<p>System：调用了System.gc()方法</p>
</li>
</ul>
<p><strong>透过日志看GC前后情况</strong></p>
<p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">PSYoungGen</span><span class="o">:</span> <span class="n">5986K</span><span class="o">-&gt;</span><span class="n">696K</span> <span class="o">(</span><span class="n">8704K</span><span class="o">)</span> <span class="o">]</span> <span class="n">5986K</span><span class="o">-&gt;</span><span class="n">704K</span> <span class="o">(</span><span class="n">9216K</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p>
</li>
<li>
<p>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
</li>
</ul>
<p>注意Minor GC堆内存总容量 = 9/10 年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</p>
<p><strong>透过日志看GC时间</strong></p>
<p>GC日志中有三个时间：user，sys和real</p>
<ul>
<li>
<p>user：程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的 CPU 总时间。</p>
</li>
<li>
<p>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</p>
</li>
<li>
<p>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</p>
</li>
</ul>
<p>由于多核的原因，一般的GC事件中，real time是小于sys time＋user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys＋user time的。如果real＞sys＋user的话，则你的应用可能存在下列问题：IO负载非常重或CPU不够用。</p>
<h2 id="54-gc日志分析工具">5.4. GC日志分析工具</h2>
<p><strong>GCEasy</strong></p>
<p>GCEasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄露检测、GC暂停原因分析、JVM配置建议优化等功能，大多数功能是免费的。</p>
<p>官网地址：https://gceasy.io/</p>
<p><strong>GCViewer</strong></p>
<p>GCViewer是一款离线的GC日志分析器，用于可视化Java VM选项 -verbose:gc 和 .NET生成的数据 -Xloggc:<file>。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p>
<p>源码下载：https://github.com/chewiebug/GCViewer</p>
<p>运行版本下载：https://github.com/chewiebug/GCViewer/wiki/Changelog</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Hengyu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2022-04-08
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/mysql1-%E7%B4%A2%E5%BC%95/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">MySql-1 索引</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/jvm09-jvm%E5%8F%82%E6%95%B0/">
            <span class="next-text nav-default">JVM-9  JVM参数</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Hengyu</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
